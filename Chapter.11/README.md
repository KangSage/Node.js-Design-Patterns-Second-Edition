# Chapter 11 - 메시징과 통합 패턴

## 메시징 시스템의 기본 사항

### 메시지 및 메시징 시스템에 대해 이야기할 때 고려해야할 4가지 기본요소

- 단방향 또는 요청/응답 교환할 수 있는 통신의 방향
- 내용을 결정하는 메시지의 목적
- 즉시 또는 나중에(비동기식으로) 전송 및 수신할 수 있는 메시지 타이밍
- 직접 또는 브로커를 통해 발생할 수 있는 메시지의 전달

#### 단방향 & 요청/응답 턴

- 메시징 시스템에서 가장 기본적인 측면은 의미 결정의 통신 방향
  - 단방향으로 푸시되는 경우
    - ex) WebSocket을 사용하여 연결된 브라우저에 메시지를 보내는 이메일, 웹서버  
      또는 작업 배포 시스템 등이 있음.
  - 양방향 요청/응답 패턴
    - 단방향보다 인기있으며 구현하기 쉬워 보이지만  
      통신이 비동기이거나 여러 개의 노드가 포함되어 있으면 복잡해진다.
    - 일반적으로 응답은 요청과 동일한 컨텍스트에서 처리된다.

#### 메시지 유형

메시지는 본질적으로 다른 소프트웨어 컴포넌트를 연결하는 수단
목적은 다른 시스템/컴포넌트가 보유한 정보를 획득, 원격 작업을 실행, 이벤트 발생 알림 등
통신 이유에 따른 3가지 메시지

- 명령 메시지

  - 직렬화된 명령 객체
    - 목적은 수신 측에서 어떤 동작이나 작업을 수행하도록 명령을 내리는 것
    - 명령 수행을 위해 필요한 연산 명칭, 실행에 주어지는 인자 값들의 기본 정보를 가져야함.
    - 원격 프로시저 호출(RPC) 시스템, 분산된 연산 수행, 데이터 요청 등에 사용
      - ex) RESTful HTTP 호출, gRPC 등

- 이벤트 메시지

  - 이벤트 메시지는 다른 컴포넌트에 무엇인가가 발생했음을 알리는데 사용
  - 일반적으로 이벤트의 유형을 포함하며 때때로 컨텍스트, 주제 또는 관련 수행자 등의 세부 정보도 포함됨.
  - 브라우저의 롱 폴링, WebSocket 등을 통하여  
    데이터 혹은 시스템의 상태 변경이 있을 때 서버에서 알림을 받기 위해 사용.
  - 이벤트의 사용은 시스템의 모든 노드를 동일한 페이지에서 유지시키므로  
    분산 어플리케이션에서 매우 중요한 통합 매커니즘

- 도큐먼트 메시지

  - 도큐먼트 메시지는 기본적으로 컴포넌트와 시스템 간의 데이터 전송을 의미
  - 도큐먼트 메시지가 명령 메시지와 구별되는 주요 특징은 수신자에게  
    데이터 처리 방법 등에 대한 정보를 메시지에 담아 주지 않는다는 것
  - 이벤트 메시지와는 발생한 특정 사건과 연관성이 없다는 것
  - 주로 명령 메시지에 대한 응답에 요청 된 데이터 또는 작업의 결과만 포함되므로  
    도큐먼트 메시지인 경우가 많다.

#### 비동기 메시징 및 큐

동기식 메시지 예시 - 전화

- 전화 통화는 동시에 동인한 채널에 연결되어 실시간으로 메시지를 교환
- 다른 사람에게 전화를 걸려면 다른 전화가 필요하거나 기존의 통화를 끊어야 함

비동기식 메시지 예시 - SMS

- 전송 시 받는 사람은 네트워크에 연결할 필요가 없음
- 즉시 또는 일정 지연 후 응답을 받거나 전혀 응답을 받지 못할 경우도 있음
- 여러 수신자에게 여러 개의 SMS를 차례로 보내고 응답 순서와 상관없이 응답을 받을 수 있음
- 더 적은 리소스로 더 나은 병렬 처리 가능

비동기 통신의 이점은 메시지를 저장한 이후 가능한 빨리 또는 일정 지연 후에 전달 가능  
수신자가 새로운 메시지를 처리하기에 너무 바쁘거나 메시지 전달을 보장해야할 경우 유용

통신을 중재하고 메시지가 대상에 전달되기 전에 저장하는 컴포넌트인  
메시지 큐를 사용하여 이런 작업을 수행 가능

#### P2P 또는 브로커 기반 메시징

메시지는 수신자에게 직접 P2P 방식 또는  
메시지 브로커라는 중앙 중계 시스템을 통해 수신자에게 직접 전달 가능  
브로커의 주된 역할은 메시지 수신자를 발신자에게서 분리하는 것  
P2P 아키텍처에서 모든 노드는 메시지를 수신자에게 직접 전달함  
이는 노드가 수신자의 주소와 포트를 알아야하고 프로토콜과 메시지 형식을 이해하고 있어야함

브로커는 이런 복잡성을 방정식에서 제거하고 다른 통신 프로토콜 간의 브릿지 역할도 할 수 있다  
각 노드는 완전 독립적일 수 있고 세부 정보를 몰라도 정의 되지 않은 피어들과 통신 가능  
디커플링, 상호 운용성 외에도 브로커는 영구적인 큐(persistent queue),  
라우팅(routing), 메시지 변환 및 모니터링 등의 고급 기능을 제공 가능

대표적 메시지 브로커들

- RabbitMQ
- AMQP (Advanced Message Queuing Protocol)
- MQTT (Message Queue Telemetry Transport)
- STOMP (Simple/Streaming Text Orientated Messaging Protocol)

브로커를 피해야 하는 이유

- 단일 장애 지점의 제거
- 브로커는 확장해야 하는 반면, P2P 아키텍처에서는 단일 노드만 확장
- 브로커 없이 메시지를 교환하면 전송 속도가 빨라짐

## 게시/구독 패턴 (pub/sub)

가장 잘 알려진 단방향 메시징 패턴으로 이것은 결국 분산된 관찰자 패턴(observer pattern)임  
일련의 구독자가 메시지 수신을 위해 구독을 등록하고  
게시자는 모든 관련 구독자에게 배포되는 메시지를 생성  
pub/sub 패턴의 두 가지 주요 변형으로 게시자가 직접 구독자들에게 배포하는 유형과  
브로커가 게시자와 구독자의 통신 중재를 하는 유형이 있다

pub/sub을 특별하게 만드는 이유는 게시자가  
메시지의 수신자가 누구인지 미리 알 필요가 없기 때문  
특정 메시지를 받기 위해서는 구독자가 자신의 관심사 등록을 해야하므로  
게시자는 익명 수신자와 함께 작업 할 수 있다

양쪽이 느슨하게 결합되어 있으므로 진화하는 분산 시스템의 노드를 통합하는 데 이상적이다.  
브로커가 존재하면 구독자가 메시지의 게시자인 노드를 알지 못해 브로커와만  
상호작용을 하므로 시스템 노드간의 문리가 더욱 개선됨

### 간단한 실시간 채팅 어플리케이션 만들기

pub/sub 패턴이 분산 아키텍처를 통합하는데 어떻게 도움이 되는지 보기 위해  
순수한 WebSockets를 사용하여 기본적인 실시간 채팅 어플리케이션을 만든다  
여러 인스턴스를 실행하여 메시징 시스템을 통한 통신에 참여시키고 규모 조정을 해본다.

[실습 예제](./real-time-chat-app)

### 메시지 브로커로 Redis 사용하기

Redis는 메시지 브로커라기 보다는 데이터베이스(매우 빠르고 유연한 k/v 저장소)이지만  
중앙 집중식 pub/sub 패턴을 구현하도록 특별히 설계된 명령 쌍이 존재  
진보된 메시지 지향 미들웨어들과 비교할 때 매우 간단하고 기본적이지만 그래서 인기가 많음  
이미 시스템에서 사용 중인 캐싱 서버나 세션 저장소와 같은 인프라에서 사용 가능  
속도와 유연성을 갖추고 있고 Redis를 재사용하여 관리포인트를 줄일 수 있으므로  
가장 간단하고 즉각적인 선택지이기도 함

이 프로젝트의 계획은 Redis를 메시지 브로커로 사용하여 채팅 서버 인스턴스들을 통합하는 것  
각 인스턴스는 클라이언트에서 수신한 메시지를 브로커에 게시하는 동시에 모든 메시지를 구독  
아키텍처의 각 서버는 구독자이면서 게시자임

> 아키텍처의 메시지 흐름
>
> 1. 메시지는 웹 페이지에서 입력되어 채팅 서버의 인스턴스로 전송
> 2. 메시지는 브로커에 Pub
> 3. 브로커는 모든 구독자에게 메시지를 발송 (아키텍처 상에선 모든 서버 인스턴스)
> 4. 각 인스턴스의 메시지는 연결된 모든 클라이언트에 전파

우선 Redis 개발 환경을 준비한다 - Docker로 간단하게 개발환경 준비

#### [Docker 설치하기](https://dc7303.github.io/docker/2019/11/24/dockerInstallForMac/)

```shell
# brew로 Docker를 설치할 경우 일반 brew와 brew cask 두가지 방법이 존재
# brew cask의 Docker는 Docker Desktop on Mac 도커를 설치해주며
# docker-compose, docker-machine을 같이 설치해줘서 깔끔

$ brew install docker --cask

# 정상적으로 설치되었는지 버전 확인

$ docker --version
```

#### [Docker로 Redis 순식간에 설치하기](https://dingrr.com/blog/post/redis-%EB%8F%84%EC%BB%A4docker%EB%A1%9C-redis-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0)

```shell
# docker hub에서 redis latest image를 다운로드

$ docker pull redis

# 다운받은 image 확인

$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
redis               latest              74d107221092        12 days ago         104MB

# redis-cli 구성을 위해 통신할 준비 - 네트워크 구성

$ docker network create redis-net

# 컨테이너를 구분해줄 이름을 [name]에 넣고 실행
# 6379포트 redis-net이라는 브릿지가 사용

$ docker run --name [name] -p 6379:6379 --network redis-net -d redis redis-server --appendonly yes

# redis-cli로 실행한 [name] Redis 서버에 접속
# --rm 옵션은 기존 컨테이너가 존재하면 삭제하고 재실행
$ docker run -it --network redis-net --rm redis redis-cli -h [name]

# 접속 후 테스트로 Redis 명령어를 실행해본다

$ select 0     # 0번째 DB 사용 선택
$ select 1     # 1번째 DB 사용 선택
$ keys *       # 모든 키 조회
$ key *index*  # index 포함된 키 조회
$ del abcd     # abcd 키 삭제
```

## 파이프라인 및 작업 배포 패턴

## 요청(request)/응답(reply) 패턴
